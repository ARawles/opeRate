# tidyverse

As we learnt in the [teacheR](teacher.arawles.co.uk) book, R is supported by thousands of packages that provide extra functionality to the base R experience. One of the most popular sets of packages developed by Hadley Wickham and the RStudio Team is called the [tidyverse](https://www.tidyverse.org/). The tidyverse is made up of packages designed for data science work that are all underpinned by a common philosophy and a common syntax. At the core of this philosophy is the concept of "tidiness" in data.

The tidyverse is a set of **opinionated** packages. That means that there's (usually) a right way to do things with the package, and there's a wrong way. There's much debate in the R community as to whether relying heavily on opinionated external packages such as those included in the tidyverse is a good thing. Personally, I think that the packages included in the tidyverse are fantastic, and are a large reason why R is thriving today.

So in this book, we're a tidyverse family, and we'll be using the tidyverse packages throughout.

## "Tidy" data

The concept of "tidy" data is something that's important throughout the set of tidyverse packages. There is an [in-depth paper](https://vita.had.co.nz/papers/tidy-data.html) published in the Journal of Statistical Software, authored by Hadley Wickham, that describes the concept and requirements of tidy data in full. But for now we're just going to look at the basics.

In order for a dataset to be tidy, it needs to abide by three rules:

  1. Every column is a variable
  2. Every row is an observation
  3. Every cell is a single value

If a dataset doesn't abide by all three of these rules, then it's a "messy" dataset.

The benefit of having your data in a tidy format is fairly simple; it provides a standard for structuring a dataset. This means that tools can be developed with the assumption that the data will be in a specific format, making the development of these data science tools easier. And this is essentially what underpins the entire tidyverse: get your data in a tidy format and you'll have access to everything the tidyverse provides.

## The pipe `%>%`

The pipe is a core feature of the tidyverse packages, and has proved so popular in its R implementation that it served as the inspiration for the `|>` function that was introduced into R in version 4.0. For now we're going to look specifically at the tidyverse (or more specifically the `magrittr`) implementation of the pipe but they are very similar.

At the simplest level, the pipe takes the output from whatever is on its left and passes it as the first argument to the expression on the right. Like this:

```{r}
1 %>% print()
```

In this example, the 1 is passed as the first argument to the `print()` function, which prints it out.

You can also specify which argument you want the value to be passed as by using the `.` shorthand:

```{r}
1 %>% substr("water", ., 2)
```
This passes the 1 from the left hand side as the second argument to the `substr()` function (which is the `start` index).

The benefit of the pipe is that it allows you to read code from left to right, rather than from middle outwards. Let's compare two examples with an without the pipe:


```{r}
str <- "water"

print(paste0(substr(str, 1, 1), "ine"))

str %>% substr(1,1) %>% paste0("ine") %>% print()
```

Although the outcome is exactly the same, following the flow of logic is much easier in the bottom example because we can start at the left and more rightwards.

For the purposes of this book that's as much as you need to know. You'll see the pipe used a lot when we're performing multiple data analysis steps, like cleaning then filtering then selecting columns and so on. So as long as you've grasped the simple concept; we're taking the left hand side and passing it to the right, then you'll be fine.

## Quasiquotation

In the [teacheR](https://teacher.arawles.co.uk) book, we looked at the concept of quasiquotation; selectively quoting and then evaluating parts of an expression. The tidyverse packages rely heavily on this concept, which is why you'll often see (for example) column names passed to the tidyverse packages as variable names rather than character strings, like this:

```{r, eval = FALSE}
my_df %>%
  dplyr::mutate(new_column = old_column + 1)

```

This might seem odd when you first start using this approach; isn't the function going to look for a variable in the global environment called `old_column` and then fail when it can't find it?

When you pass a column name like this, the tidyverse packages will quote that input and then evaluate the resulting expression in the context of the current data frame. So essentially, R looks for the `old_column` object in the context of `my_df`, rather than in the global environment. Because dataframes are essentially just lists and lists can be treated like environments, it searches that environment for the `old_column` object and finds it, returning the contents of the column.


### tidyselect

Much of this functionality is powered by a package called `{tidyselect}`. The `{tidyselect}` package provides a number of functions for selecting variables from datasets, reducing the time spent laboriously typing out the name of every variable you want to reference.

To better understand the specifics of the `{tidyselect}` dialect and how it interacts with the tidyverse packages, there are a number of [vignettes](https://tidyselect.r-lib.org/reference/language.html) included in the package that explain things well. For now however, if you can understand the basic concept that variables are evaluated in the specific context of the dataset provided to the function, then you should be fine.
